#ifndef __3DFIER__polyfit__
#define __3DFIER__polyfit__
#include <vector>
#include "matrix.hpp"
#include "givensQR.hpp"
/*
Finds the coefficients of a polynomial p(x) of degree n that fits the data,
p(x(i)) to y(i), in a least squares sense. The result p is a row vector of
length n+1 containing the polynomial coefficients in incremental powers.

param:
oX				x axis values
oY				y axis values
nDegree		polynomial degree including the constant

return:
coefficients of a polynomial starting at the constant coefficient and
ending with the coefficient of power to nDegree. C++0x-compatible
compilers make returning locally created vectors very efficient.
*/
template<typename T>
std::vector<T> polyfitqr(const std::vector<T>& oX, const std::vector<T>& oY, int nDegree) {
  if (oX.size() != oY.size())
    throw std::invalid_argument("X and Y vector sizes do not match");

  // more intuative this way
  nDegree++;

  size_t nCount = oX.size();
  mathalgo::matrix<T> oXMatrix(nCount, nDegree);
  mathalgo::matrix<T> oYMatrix(nCount, 1);

  // copy y matrix
  for (size_t i = 0; i < nCount; i++) {
    oYMatrix(i, 0) = oY[i];
  }

  // create the X matrix
  for (size_t nRow = 0; nRow < nCount; nRow++) {
    T nVal = 1.0f;
    for (int nCol = 0; nCol < nDegree; nCol++) {
      oXMatrix(nRow, nCol) = nVal;
      nVal *= oX[nRow];
    }
  }

  // transpose X matrix
  mathalgo::matrix<T> oXtMatrix(oXMatrix.transpose());
  // multiply transposed X matrix with X matrix
  mathalgo::matrix<T> oXtXMatrix(oXtMatrix * oXMatrix);
  // multiply transposed X matrix with Y matrix
  mathalgo::matrix<T> oXtYMatrix(oXtMatrix * oYMatrix);

  mathalgo::Givens<T> oGivens;
  oGivens.Decompose(oXtXMatrix);
  mathalgo::matrix<T> oCoeff = oGivens.Solve(oXtYMatrix);
  // copy the result to coeff
  return oCoeff.data();
}

/*
Calculates the value of a polynomial of degree n evaluated at x. The input
argument pCoeff is a vector of length n+1 whose elements are the coefficients
in incremental powers of the polynomial to be evaluated.

param:
oCoeff			polynomial coefficients generated by polyfit() function
oX				x axis values

return:
Fitted Y values. C++0x-compatible compilers make returning locally
created vectors very efficient.
*/
template<typename T>
std::vector<T> polyvalqr(const std::vector<T>& oCoeff, const std::vector<T>& oX) {
  size_t nCount = oX.size();
  size_t nDegree = oCoeff.size();
  std::vector<T>	oY(nCount);

  for (size_t i = 0; i < nCount; i++) {
    T nY = 0;
    T nXT = 1;
    T nX = oX[i];
    for (size_t j = 0; j < nDegree; j++) {
      // multiply current x by a coefficient
      nY += oCoeff[j] * nXT;
      // power up the X
      nXT *= nX;
    }
    oY[i] = nY;
  }

  return oY;
}

template<typename T>
void combineXY(std::vector<T>& oX, std::vector<T>& oY, T x0, T y0, mathalgo::matrix<T>& oXY) {
  size_t nCount = oX.size();
  size_t nCols = 3 * 2; // 3 unknowns in 2 dimensions
  oXY = mathalgo::matrix<T>(nCount, nCols);

  // create the XY matrix
  for (size_t nRow = 0; nRow < nCount; nRow++) {
    T x = oX[nRow] - x0;
    T y = oY[nRow] - y0;
    if (nRow == 0) {
      x = 0;
      y = 0;
    }
    oXY(nRow, 0) = 1;
    oXY(nRow, 1) = x;
    oXY(nRow, 2) = y;
    oXY(nRow, 3) = x * y;
    oXY(nRow, 4) = x * x;
    oXY(nRow, 5) = y * y;
  }
}

// 3D plane fitting
template<typename T>
void polyfit3d(std::vector<T>& oX, std::vector<T>& oY, std::vector<T>& oZ, T x0, T y0, std::vector<T>& coeffs, std::vector<T>& calculated) {
  if (oX.size() != oY.size() || oX.size() != oZ.size())
    throw std::invalid_argument("X and Y or X and Z vector sizes do not match");

  size_t nCount = oX.size();
  mathalgo::matrix<T> A;
  combineXY(oX, oY, x0, y0, A);
  mathalgo::matrix<T> X(nCount, 1);

  // copy z matrix
  for (size_t i = 0; i < nCount; i++) {
    X(i, 0) = oZ[i];
  }

  // Y=(AT*A)-1*AT*X
  // transpose X matrix
  mathalgo::matrix<T> AT;
  A.transpose(AT);
  // multiply transposed X matrix with X matrix
  mathalgo::matrix<T> ATA;
  AT.multiply(A, ATA);
  // multiply transposed X matrix with Y matrix
  mathalgo::matrix<T> ATX;
  AT.multiply(X, ATX);

  mathalgo::Givens<T> oGivens;
  oGivens.Decompose(ATA);
  mathalgo::matrix<T> Y;
  oGivens.Solve(ATX, Y);

  mathalgo::matrix<T> YT;
  Y.transpose(YT);
  mathalgo::matrix<T> AY;
  A.multiply(YT, AY);

  calculated = AY.data();
  // copy the result to coeff
  coeffs = Y.data();
}

template<typename T>
void polyval3d(std::vector<T>& x, std::vector<T>& y, T x0, T y0, std::vector<T>& coeff, std::vector<T>& calculated) {
  mathalgo::matrix<T> A;
  combineXY(x, y, x0, y0, A);
  mathalgo::matrix<T> YT(coeff.size(), 1);
  // build coeff matrix
  for (size_t i = 0; i < coeff.size(); i++) {
    YT(i, 0) = coeff[i];
  }
  mathalgo::matrix<T> AY;
  A.multiply(YT, AY);
  calculated = AY.data();
}
#endif